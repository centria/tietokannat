{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/tehokkuus",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Tehokkuus\",\n  \"nav_order\": 9,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"kyselyjen-suoritus\"\n  }, \"Kyselyjen suoritus\"), mdx(\"p\", null, \"SQL-kieli on tietokannan k\\xE4ytt\\xE4j\\xE4lle mukava kyselyjen tekemisess\\xE4, koska k\\xE4ytt\\xE4j\\xE4n riitt\\xE4\\xE4 kuvata, mit\\xE4 tietoa h\\xE4n haluaa hakea, ja tietokantaj\\xE4rjestelm\\xE4 hoitaa loput. Niinp\\xE4 tietokantaj\\xE4rjestelm\\xE4n on t\\xE4rke\\xE4\\xE4 pysty\\xE4 l\\xF6yt\\xE4m\\xE4\\xE4n jokin tehokas tapa toteuttaa k\\xE4ytt\\xE4j\\xE4n antama kysely ja toimittaa kyselyn tulokset k\\xE4ytt\\xE4j\\xE4lle.\"), mdx(\"h2\", {\n    \"id\": \"kyselyn-suunnitelma-explain\"\n  }, \"Kyselyn suunnitelma (Explain)\"), mdx(\"p\", null, \"Monet tietokantaj\\xE4rjestelm\\xE4t kertovat pyydett\\xE4ess\\xE4 suunnitelmansa, miten annettu kysely aiotaan suorittaa. T\\xE4m\\xE4n avulla voimme tutkia tietokantaj\\xE4rjestelm\\xE4n sis\\xE4ist\\xE4 toimintaa.\"), mdx(\"p\", null, \"Tarkastellaan esimerkkin\\xE4 kysely\\xE4, joka hakee retiisin tiedot taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"SELECT * FROM Products WHERE name='radish';\\n\")), mdx(\"p\", null, \"Kun laitamme SQLitess\\xE4 kyselyn eteen sanan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EXPLAIN\"), \", saamme seuraavan tapaisen selostuksen suunnitelmasta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> EXPLAIN SELECT * FROM Products WHERE name='radish';\\naddr  opcode         p1    p2    p3    p4             p5  comment      \\n----  -------------  ----  ----  ----  -------------  --  -------------\\n0     Init           0     12    0                    00  Start at 12  \\n1     OpenRead       0     2     0     3              00  root=2 iDb=0; Products\\n2     Rewind         0     10    0                    00               \\n3       Column         0     1     1                    00  r[1]=Products.name\\n4       Ne             2     9     1     (BINARY)       52  if r[2]!=r[1] goto 9\\n5       Rowid          0     3     0                    00  r[3]=rowid   \\n6       Copy           1     4     0                    00  r[4]=r[1]    \\n7       Column         0     2     5                    00  r[5]=Products.price\\n8       ResultRow      3     3     0                    00  output=r[3..5]\\n9     Next           0     3     0                    01               \\n10    Close          0     0     0                    00               \\n11    Halt           0     0     0                    00               \\n12    Transaction    0     0     1     0              01  usesStmtJournal=0\\n13    TableLock      0     2     0     Products       00  iDb=0 root=2 write=0\\n14    String8        0     2     0     radish        00  r[2]='radish'\\n15    Goto           0     1     0                    00 \\n\")), mdx(\"p\", null, \"SQLite muuttaa kyselyn tietokannan sis\\xE4iseksi \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ohjelmaksi\"), \", joka hakee tietoa tauluista. T\\xE4ss\\xE4 tapauksessa ohjelman suoritus alkaa rivilt\\xE4 12, jossa alkaa transaktio, ja sitten rivill\\xE4 14 rekisteriin 2 sijoitetaan hakuehdossa oleva merkkijono \\\"radish\\\". T\\xE4m\\xE4n j\\xE4lkeen suoritus siirtyy riville 1, jossa aloitetaan taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" k\\xE4sittely, ja rivit 2\\u20139 muodostavat silmukan, joka etsii hakuehtoa vastaavat rivit taulusta.\"), mdx(\"p\", null, \"Voimme my\\xF6s pyyt\\xE4\\xE4 tiiviimm\\xE4n suunnitelman laittamalla kyselyn eteen sanat \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EXPLAIN QUERY PLAN\"), \". T\\xE4ll\\xF6in tulos voi olla seuraava:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> EXPLAIN QUERY PLAN SELECT * FROM Products WHERE name='radish';\\n0|0|0|SCAN TABLE Products\\n\")), mdx(\"p\", null, \"T\\xE4ss\\xE4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SCAN TABLE Products\"), \" tarkoittaa, ett\\xE4 kysely k\\xE4y l\\xE4pi taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" rivit.\"), mdx(\"h2\", {\n    \"id\": \"kyselyn-optimointi-optimizing-a-query\"\n  }, \"Kyselyn optimointi (Optimizing a query)\"), mdx(\"p\", null, \"Jos kyselyss\\xE4 haetaan tietoa vain yhdest\\xE4 taulusta, kysely on yleens\\xE4 helppo suorittaa, mutta todelliset haasteet tulevat vastaan usean taulun kyselyiss\\xE4. T\\xE4ll\\xF6in tietokantaj\\xE4rjestelm\\xE4n tulee osata \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"optimoida (optimize)\"), \" kyselyn suorittamista eli muodostaa hyv\\xE4 suunnitelma, jonka avulla halutut tiedot saadaan ker\\xE4tty\\xE4 tehokkaasti tauluista.\"), mdx(\"p\", null, \"Tarkastellaan esimerkkin\\xE4 seuraavaa kysely\\xE4, joka listaa kurssien ja opettajien nimet:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT C.name, T.name FROM Courses C, Teachers T WHERE C.teacher_id = T.id;\\n\")), mdx(\"p\", null, \"Koska kysely kohdistuu kahteen tauluun, olemme ajatelleet kyselyn toiminnan niin, ett\\xE4 se muodostaa ensin kaikki rivien yhdistelm\\xE4t tauluista \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" ja \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" ja valitsee sitten ne rivit, joilla p\\xE4tee ehto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C.teacher_id = T.id\"), \". T\\xE4m\\xE4 on hyv\\xE4 ajattelutapa, mutta t\\xE4m\\xE4 ei vastaa sit\\xE4, miten kunnollinen tietokantaj\\xE4rjestelm\\xE4 toimii.\"), mdx(\"p\", null, \"Ongelmana on, ett\\xE4 tauluissa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" ja \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" voi molemmissa olla suuri m\\xE4\\xE4r\\xE4 rivej\\xE4. Esimerkiksi jos kummassakin taulussa on miljoona rivi\\xE4, rivien yhdistelmi\\xE4 olisi miljoona miljoonaa ja veisi valtavasti aikaa muodostaa ja k\\xE4yd\\xE4 l\\xE4pi kaikki yhdistelm\\xE4t.\"), mdx(\"p\", null, \"T\\xE4ss\\xE4 tilanteessa tietokantaj\\xE4rjestelm\\xE4n pit\\xE4\\xE4kin ymm\\xE4rt\\xE4\\xE4, mit\\xE4 k\\xE4ytt\\xE4j\\xE4 oikeastaan on hakemassa ja miten kyselyss\\xE4 annettu ehto rajoittaa tulosrivej\\xE4. K\\xE4yt\\xE4nn\\xF6ss\\xE4 riitt\\xE4\\xE4 k\\xE4yd\\xE4 l\\xE4pi kaikki taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" rivit ja etsi\\xE4 jokaisen rivin kohdalla jotenkin tehokkaasti yksitt\\xE4inen haluttu rivi taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \".\"), mdx(\"p\", null, \"Voimme taas pyyt\\xE4\\xE4 SQLite\\xE4 selitt\\xE4m\\xE4\\xE4n kyselyn suunnitelman:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> EXPLAIN QUERY PLAN SELECT C.name, T.name FROM Courses C, Teachers T WHERE C.teacher_id = T.id;\\n0|0|0|SCAN TABLE Courses AS C\\n0|1|1|SEARCH TABLE Teachers AS T USING INTEGER PRIMARY KEY (rowid=?)\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 kysely k\\xE4y l\\xE4pi taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" rivit (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SCAN TABLE Courses\"), \") ja hakee tietoa taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" p\\xE4\\xE4avaimen avulla (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SEARCH TABLE Teachers\"), \"). J\\xE4lkimm\\xE4inen tarkoittaa, ett\\xE4 kun k\\xE4sittelyss\\xE4 on tietty taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" rivi, kysely hakee tehokkaasti taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" rivin, jossa p\\xE4\\xE4avain \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T.id\"), \" on sama kuin \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C.teacher_id\"), \".\"), mdx(\"p\", null, \"Mutta miten k\\xE4yt\\xE4nn\\xF6ss\\xE4 taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" voi hakea tehokkaasti? T\\xE4m\\xE4 onnistuu k\\xE4ytt\\xE4m\\xE4ll\\xE4 indeksi\\xE4, joihin tutustumme heti seuraavaksi.\"), mdx(\"h1\", {\n    \"id\": \"indeksit\"\n  }, \"Indeksit\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Indeksi\"), \" on tietokannan taulun yhteyteen tallennettu hakemistorakenne, jonka tavoitteena on tehostaa tauluun liittyvien kyselyiden suorittamista. Indeksin avulla tietokantaj\\xE4rjestelm\\xE4 voi selvitt\\xE4\\xE4 tehokkaasti, miss\\xE4 p\\xE4in taulua on rivej\\xE4, jotka t\\xE4sm\\xE4\\xE4v\\xE4t tiettyyn hakuehtoon.\"), mdx(\"h2\", {\n    \"id\": \"pääavaimen-indeksi-primary-key-index\"\n  }, \"P\\xE4\\xE4avaimen indeksi (Primary key index)\"), mdx(\"p\", null, \"Kun tietokantaan luodaan taulu, sen p\\xE4\\xE4avain saa automaattisesti indeksin. T\\xE4m\\xE4n seurauksena voimme suorittaa tehokkaasti hakuja, joissa ehto liittyy p\\xE4\\xE4avaimeen.\"), mdx(\"p\", null, \"Esimerkiksi kun luomme SQLitess\\xE4 taulun\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);\\n\")), mdx(\"p\", null, \"niin taululle luodaan indeksi sarakkeelle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" ja voimme etsi\\xE4 tehokkaasti tuotteita id-numeron perusteella. T\\xE4m\\xE4n ansiosta esimerkiksi seuraava kysely toimii tehokkaasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT price FROM Products WHERE id=3;\\n\")), mdx(\"p\", null, \"Voimme varmistaa t\\xE4m\\xE4n kysym\\xE4ll\\xE4 kyselyn suunnitelman:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> EXPLAIN QUERY PLAN SELECT price FROM Products WHERE id=3;\\nselectid    order       from        detail                                                   \\n----------  ----------  ----------  ---------------------------------------------------------\\n0           0           0           SEARCH TABLE Products USING INTEGER PRIMARY KEY (rowid=?)\\n\")), mdx(\"p\", null, \"Suunnitelmassa n\\xE4kyy \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SEARCH TABLE\"), \", mik\\xE4 tarkoittaa, ett\\xE4 kysely pystyy hakemaan taulusta tietoa tehokkaasti indeksin avulla.\"), mdx(\"h2\", {\n    \"id\": \"indeksin-luominen\"\n  }, \"Indeksin luominen\"), mdx(\"p\", null, \"P\\xE4\\xE4avaimen indeksi on k\\xE4tev\\xE4, mutta voimme haluta my\\xF6s etsi\\xE4 tietoa jonkin muun sarakkeen perusteella. Esimerkiksi seuraava kysely hakee rivit sarakkeen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" perusteella:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT name FROM Products WHERE price=4;\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 kysely ei ole oletuksena tehokas, koska sarakkeelle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" ei ole indeksi\\xE4. N\\xE4emme t\\xE4m\\xE4n pyyt\\xE4m\\xE4ll\\xE4 taas selityst\\xE4 kyselyst\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> EXPLAIN QUERY PLAN SELECT name FROM Products WHERE price=4;\\nselectid    order       from        detail             \\n----------  ----------  ----------  -------------------\\n0           0           0           SCAN TABLE Products\\n\")), mdx(\"p\", null, \"Nyt suunnitelmassa n\\xE4kyy \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SCAN TABLE\"), \", mik\\xE4 tarkoittaa, ett\\xE4 kysely joutuu k\\xE4ym\\xE4\\xE4n l\\xE4pi taulun kaikki rivit. T\\xE4m\\xE4 on hidasta, jos taulussa on paljon rivej\\xE4.\"), mdx(\"p\", null, \"Voimme kuitenkin luoda uuden indeksin, joka tehostaa saraketta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" k\\xE4ytt\\xE4vi\\xE4 kyselyit\\xE4. Saamme luotua indeksin komennolla \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CREATE INDEX\"), \" n\\xE4in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE INDEX idx_price ON Products (price);\\n\")), mdx(\"p\", null, \"T\\xE4ss\\xE4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"idx_price\"), \" on indeksin nimi, jolla voimme viitata siihen my\\xF6hemmin. Indeksi toimii luonnin j\\xE4lkeen t\\xE4ysin automaattisesti, eli tietokantaj\\xE4rjestelm\\xE4 osaa k\\xE4ytt\\xE4\\xE4 sit\\xE4 kyselyiss\\xE4 ja huolehtii sen p\\xE4ivitt\\xE4misest\\xE4.\"), mdx(\"h2\", {\n    \"id\": \"miten-indeksi-toimii\"\n  }, \"Miten indeksi toimii?\"), mdx(\"p\", null, \"Indeksi tarvitsee tuekseen hakemistorakenteen, josta voi hakea tehokkaasti rivej\\xE4 sarakkeen arvon perusteella. T\\xE4m\\xE4 voidaan toteuttaa esimerkiksi puurakenteena, jonka avaimina on sarakkeiden arvoja.\"), mdx(\"p\", null, \"Indeksin luomisen j\\xE4lkeen voimme kysy\\xE4 uudestaan kyselyn suunnitelmaa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> EXPLAIN QUERY PLAN SELECT name FROM Products WHERE price=4;\\nselectid    order       from        detail                                               \\n----------  ----------  ----------  -----------------------------------------------------\\n0           0           0           SEARCH TABLE Products USING INDEX idx_price (price=?)\\n\")), mdx(\"p\", null, \"Indeksin ansiosta suunnitelmassa ei lue en\\xE4\\xE4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SCAN TABLE\"), \" vaan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SEARCH TABLE\"), \". Suunnitelmassa n\\xE4kyy my\\xF6s, ett\\xE4 aikomuksena on hy\\xF6dynt\\xE4\\xE4 indeksi\\xE4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"idx_price\"), \".\"), mdx(\"h2\", {\n    \"id\": \"lisää-käyttötapoja\"\n  }, \"Lis\\xE4\\xE4 k\\xE4ytt\\xF6tapoja\"), mdx(\"p\", null, \"Voimme k\\xE4ytt\\xE4\\xE4 indeksi\\xE4 my\\xF6s kyselyiss\\xE4, joissa haemme pienempi\\xE4 tai suurempia arvoja. Esimerkiksi sarakkeelle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price\"), \" luodun indeksin avulla voimme etsi\\xE4 vaikkapa rivej\\xE4, joille p\\xE4tee ehto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price<3\"), \" tai \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price>=8\"), \".\"), mdx(\"p\", null, \"Indeksi on my\\xF6s mahdollista luoda usean sarakkeen perusteella. Esimerkiksi voisimme luoda indeksin n\\xE4in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE INDEX idx_price ON Products (price,name);\\n\")), mdx(\"p\", null, \"T\\xE4ss\\xE4 indeksiss\\xE4 rivit on j\\xE4rjestetty ensisijaisesti hinnan ja toissijaisesti nimen mukaan. Indeksi tehostaa hakuja, joissa hakuperusteena on joko pelkk\\xE4 hinta tai yhdess\\xE4 hinta ja nimi. Kuitenkaan indeksi ei tehosta hakuja, joissa hakuperusteena on pelkk\\xE4 nimi.\"), mdx(\"h2\", {\n    \"id\": \"milloin-luoda-indeksi\"\n  }, \"Milloin luoda indeksi?\"), mdx(\"p\", null, \"Periaatteessa voisi ajatella, ett\\xE4 taulun jokaiselle sarakkeelle kannattaa luoda indeksi, jolloin monenlaiset kyselyt ovat nopeita. T\\xE4m\\xE4 ei ole kuitenkaan k\\xE4yt\\xE4nn\\xF6ss\\xE4 hyv\\xE4 idea.\"), mdx(\"p\", null, \"Vaikka indeksit tehostavat kyselyit\\xE4, niiss\\xE4 on my\\xF6s kaksi ongelmaa: indeksin hakemistorakenne vie tilaa ja indeksi my\\xF6s hidastaa tiedon lis\\xE4\\xE4mist\\xE4 ja muuttamista. J\\xE4lkimm\\xE4inen johtuu siit\\xE4, ett\\xE4 kun taulun sis\\xE4lt\\xF6 muuttuu, niin muutos t\\xE4ytyy my\\xF6s p\\xE4ivitt\\xE4\\xE4 kaikkiin tauluun liittyviin indekseihin. Indeksi\\xE4 ei siis kannata luoda huvin vuoksi.\"), mdx(\"p\", null, \"Hyv\\xE4 syy indeksin luontiin on, ett\\xE4 haluamme suorittaa usein tietynlaisia kyselyit\\xE4 ja ne toimivat hitaasti, koska tietokantaj\\xE4rjestelm\\xE4 joutuu k\\xE4ym\\xE4\\xE4n l\\xE4pi turhaan jonkin taulun kaikki rivit kyselyn aikana. T\\xE4ll\\xF6in voimme lis\\xE4t\\xE4 taululle indeksin, jonka avulla t\\xE4llaiset kyselyt toimivat jatkossa tehokkaasti.\"), mdx(\"p\", null, \"Indekseill\\xE4 on k\\xE4yt\\xE4nn\\xF6ss\\xE4 suuri vaikutus tietokantojen tehokkuuteen. Moni tietokanta toimii hitaasti sen takia, ett\\xE4 siit\\xE4 puuttuu oleellisia indeksej\\xE4. Tasapaino riitt\\xE4vien ja liian monen indeksin v\\xE4lill\\xE4 on herkk\\xE4, ja pit\\xE4isi ottaa huomioon tietokantojen kehityksess\\xE4.\"), mdx(\"h1\", {\n    \"id\": \"tiedon-toisteisuus\"\n  }, \"Tiedon toisteisuus\"), mdx(\"p\", null, \"Ideaalitilanteessa tietokantaa suunnitellessa tietokanta ei sis\\xE4ll\\xE4 toisteista tietoa, joka pystytt\\xE4isiin p\\xE4\\xE4ttelem\\xE4\\xE4n toisaalta tietokannassa. Joskus meid\\xE4n t\\xE4ytyy hieman taivuttaa t\\xE4t\\xE4 s\\xE4\\xE4nt\\xF6\\xE4 tehd\\xE4ksemme kyselyist\\xE4mme tehokkaampia.\"), mdx(\"h2\", {\n    \"id\": \"esimerkki\"\n  }, \"Esimerkki\"), mdx(\"p\", null, \"Tarkastellaan pankin tietokantaa, jossa taulu \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transactions\"), \" sis\\xE4lt\\xE4\\xE4 tietoa tilisiirroista. Jokaiselle siirrolle on sarake \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"change\"), \" joka indikoi kuinka paljon tilin tase muuttuu (eli arvo voi olla positiivinen tai negatiivinen).\"), mdx(\"p\", null, \"Seuraava esimerkki palauttaa tilin t\\xE4m\\xE4nhetkisen saldon tilille 123 laskemalla yhteen kaikki tiliin liittyv\\xE4t muutokset:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT SUM(change) FROM Transactions WHERE account_id=123;\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 on sin\\xE4ns\\xE4 hyv\\xE4 kysely, mutta sen pit\\xE4\\xE4 k\\xE4yd\\xE4 l\\xE4pi kaikki tiliin 123 liittyv\\xE4t rivit taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transactions\"), \" l\\xF6yt\\xE4\\xE4kseen nykyisen saldon. T\\xE4m\\xE4 on melkolailla ylim\\xE4\\xE4r\\xE4ist\\xE4 ty\\xF6t\\xE4, sill\\xE4 meit\\xE4 ei kiinnosta historia vaan ainoastaan saldo.\"), mdx(\"p\", null, \"Voimme tehd\\xE4 kyselyst\\xE4 tehokkaamman luomalla uuden taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Balances\"), \", joka sis\\xE4lt\\xE4\\xE4 tilien saldot. T\\xE4m\\xE4n taulun avulla voimme hakea saldon tilille 123 n\\xE4in helposti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"SELECT balance FROM Balances FROM account_id=123;\\n\")), mdx(\"p\", null, \"T\\xE4ss\\xE4 rikomme periaatetta, ett\\xE4 tietokannassa ei pit\\xE4isi olla tietoa joka voidaan laskea muualta tietokannasta, sill\\xE4 taulu \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Balances\"), \" pystyt\\xE4\\xE4n laskemaan taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transactions\"), \". T\\xE4ll\\xE4 tavoin tosin voimme tehd\\xE4 todella paljon tehokkaamman kyselyn.\"), mdx(\"p\", null, \"Mit\\xE4 vikaa on periaatteen rikkomisessa? No, teimme juuri tietokannan p\\xE4ivitt\\xE4misest\\xE4 hankalampaa. Joka kerta kun nyt lis\\xE4\\xE4mme uuden rivin tauluun `\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transactions\"), \", joudumme my\\xF6s p\\xE4ivitt\\xE4m\\xE4\\xE4n tietoa taulussa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Balances\"), \". Aiemmin saldo laskettiin suoraan tilisiirroista, joka oli aina ajantasalla.\"), mdx(\"h2\", {\n    \"id\": \"denormalisointi-denormalization\"\n  }, \"Denormalisointi (Denormalization)\"), mdx(\"p\", null, \"Tietokantojen teoriassa k\\xE4ytet\\xE4\\xE4n termi\\xE4 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"denormalisointi (denormalization)\"), \", mik\\xE4 tarkoittaa kyselyiden tehostamista lis\\xE4\\xE4m\\xE4ll\\xE4 toisteista tietoa. T\\xE4ll\\xE4 kertaa teemme siis melko p\\xE4invastaista kuin normalisoidessa.\"), mdx(\"h2\", {\n    \"id\": \"muutokset-vastaan-kyselyt\"\n  }, \"Muutokset vastaan kyselyt\"), mdx(\"p\", null, \"Usein esiintyv\\xE4 ilmi\\xF6 tietotekniikassa on, ett\\xE4 joudumme tasapainoilemaan sen kanssa, haluammeko muuttaa vai hakea tehokkaasti tietoa ja paljonko tilaa voimme k\\xE4ytt\\xE4\\xE4. T\\xE4m\\xE4 tulee tietokantojen lis\\xE4ksi vastaan esimerkiksi algoritmien suunnittelussa.\"), mdx(\"p\", null, \"Jos tietokannassa ei ole toisteista tietoa, muutokset ovat helppoja, koska jokainen tieto on vain yhdess\\xE4 paikassa eli riitt\\xE4\\xE4 muuttaa vain yhden taulun yht\\xE4 rivi\\xE4. My\\xF6s hyv\\xE4n\\xE4 puolena tietokanta vie v\\xE4h\\xE4n tilaa. Toisaalta kyselyt voivat olla monimutkaisia ja hitaita, koska halutut tiedot pit\\xE4\\xE4 ker\\xE4t\\xE4 kasaan eri puolilta tietokantaa.\"), mdx(\"p\", null, \"Kun sitten lis\\xE4\\xE4mme toisteista tietoa, pystymme nopeuttamaan kyselyj\\xE4 mutta toisaalta muutokset hidastuvat, koska muutettu tieto pit\\xE4\\xE4 p\\xE4ivitt\\xE4\\xE4 useaan paikkaan. Samaan aikaan my\\xF6s tietokannan tilank\\xE4ytt\\xF6 kasvaa toisteisen tiedon takia.\"), mdx(\"p\", null, \"Valitettavasti ei ole mit\\xE4\\xE4n yleist\\xE4 s\\xE4\\xE4nt\\xF6\\xE4, paljonko toisteista tietoa kannattaa lis\\xE4t\\xE4, vaan t\\xE4m\\xE4 riippuu tietokannan sis\\xE4ll\\xF6st\\xE4 ja halutuista kyselyist\\xE4. Yksi hyv\\xE4 tapa on aloittaa tilanteesta, jossa toisteista tietoa ei ole, ja lis\\xE4t\\xE4 sitten toisteista tietoa tarvittaessa, jos osoittautuu, ett\\xE4 kyselyt eiv\\xE4t muuten ole riitt\\xE4v\\xE4n tehokkaita.\"), mdx(\"p\", null, \"Huomaa, ett\\xE4 indeksointi on my\\xF6s yksi esimerkki kuinka toisteinen tieto tekee kyselyist\\xE4 tehokkaampia. T\\xE4ll\\xF6in toisteinen tieto ei ole talletettu tauluihin, vaan taulujuen ulkopuolelle omiin tietorakenteisiinsa.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#kyselyjen-suoritus","title":"Kyselyjen suoritus","items":[{"url":"#kyselyn-suunnitelma-explain","title":"Kyselyn suunnitelma (Explain)"},{"url":"#kyselyn-optimointi-optimizing-a-query","title":"Kyselyn optimointi (Optimizing a query)"}]},{"url":"#indeksit","title":"Indeksit","items":[{"url":"#pääavaimen-indeksi-primary-key-index","title":"Pääavaimen indeksi (Primary key index)"},{"url":"#indeksin-luominen","title":"Indeksin luominen"},{"url":"#miten-indeksi-toimii","title":"Miten indeksi toimii?"},{"url":"#lisää-käyttötapoja","title":"Lisää käyttötapoja"},{"url":"#milloin-luoda-indeksi","title":"Milloin luoda indeksi?"}]},{"url":"#tiedon-toisteisuus","title":"Tiedon toisteisuus","items":[{"url":"#esimerkki","title":"Esimerkki"},{"url":"#denormalisointi-denormalization","title":"Denormalisointi (Denormalization)"},{"url":"#muutokset-vastaan-kyselyt","title":"Muutokset vastaan kyselyt"}]}]},"frontmatter":{"title":"Tehokkuus"}}},"pageContext":{"id":"689c205f-0a14-5275-a693-f391866ded3d"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}