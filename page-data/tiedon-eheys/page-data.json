{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/tiedon-eheys",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Tiedon eheys\",\n  \"nav_order\": 8,\n  \"hidden\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"tiedon-eheys-data-integrity\"\n  }, \"Tiedon eheys (data integrity)\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Tiedon eheys (data integrity)\"), \" viittaa siihen, ett\\xE4 tietokannassa oleva tieto on paikkansa pit\\xE4v\\xE4\\xE4 ja ristiriidatonta. P\\xE4\\xE4vastuu tiedon laadusta on toki k\\xE4ytt\\xE4j\\xE4ll\\xE4 tai sovelluksella, joka muuttaa tietokantaa, mutta my\\xF6s tietokannan suunnittelija voi vaikuttaa asiaan lis\\xE4\\xE4m\\xE4ll\\xE4 tauluihin ehtoja, jotka tarkkailevat tietokantaan sy\\xF6tett\\xE4v\\xE4\\xE4 tietoa.\"), mdx(\"h2\", {\n    \"id\": \"sarakkeiden-ehdot-column-conditions\"\n  }, \"Sarakkeiden ehdot (Column conditions)\"), mdx(\"p\", null, \"Voimme m\\xE4\\xE4ritt\\xE4\\xE4 taulun luonnin yhteydess\\xE4 sarakkeisiin liittyvi\\xE4 ehtoja, joita tietokantaj\\xE4rjestelm\\xE4 valvoo tiedon lis\\xE4\\xE4misen ja muuttamisen yhteydess\\xE4. N\\xE4ill\\xE4 ehdoilla voi ohjata sit\\xE4, millaista tietoa tietokantaan ilmestyy. Tyypillisi\\xE4 ehtoja ovat seuraavat:\"), mdx(\"h2\", {\n    \"id\": \"unique\"\n  }, \"UNIQUE\"), mdx(\"p\", null, \"Ehto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UNIQUE\"), \" tarkoittaa, ett\\xE4 kyseisess\\xE4 sarakkeessa tulee olla eri arvo joka rivill\\xE4. Esimerkiksi seuraavassa taulussa vaatimuksena on, ett\\xE4 joka tuotteella on eri nimi:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT UNIQUE, price INTEGER);\\n\")), mdx(\"h2\", {\n    \"id\": \"not-null-ja-default\"\n  }, \"NOT NULL ja DEFAULT\"), mdx(\"p\", null, \"Ehto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NOT NULL\"), \" tarkoittaa, ett\\xE4 kyseisess\\xE4 sarakkeessa ei saa olla arvoa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \". Esimerkiksi seuraavassa taulussa tuotteen hinta ei saa olla tyhj\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER NOT NULL);\\n\")), mdx(\"p\", null, \"T\\xE4h\\xE4n liittyy usein my\\xF6s m\\xE4\\xE4re \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DEFAULT\"), \", jonka seurauksena sarake saa tietyn oletusarvon, jos sille ei anneta arvoa rivin lis\\xE4\\xE4misess\\xE4. Esimerkiksi voimme m\\xE4\\xE4ritt\\xE4\\xE4 oletusarvon 0 n\\xE4in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER DEFAULT 0);\\n\")), mdx(\"h2\", {\n    \"id\": \"check\"\n  }, \"CHECK\"), mdx(\"p\", null, \"Yleisempi tapa luoda ehto on k\\xE4ytt\\xE4\\xE4 avainsanaa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CHECK\"), \", jonka j\\xE4lkeen voi kirjoittaa mink\\xE4 tahansa ehtolausekkeen. Esimerkiksi seuraava komento luo taulun tuotteista, jossa rivin ehtona on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price >= 0\"), \" eli hinta ei saa olla negatiivinen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price CHECK (price >= 0));\\n\")), mdx(\"h2\", {\n    \"id\": \"ehtojen-valvonta-condition-monitoring\"\n  }, \"Ehtojen valvonta (Condition monitoring)\"), mdx(\"p\", null, \"Ehtojen hy\\xF6tyn\\xE4 on, ett\\xE4 tietokantaj\\xE4rjestelm\\xE4 valvoo niit\\xE4 ja kielt\\xE4ytyy tekem\\xE4st\\xE4 lis\\xE4yst\\xE4 tai muutosta, joka rikkoisi ehdon. Seuraavassa on esimerkki t\\xE4st\\xE4 SQLitess\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> CREATE TABLE Products (id INTEGER PRIMARY KEY, name TEXT, price CHECK (price >= 0));\\nsqlite> INSERT INTO Products(name,price) VALUES ('radish',4);\\nsqlite> INSERT INTO Products(name,price) VALUES ('celery',7);\\nsqlite> INSERT INTO Products(name,price) VALUES ('cucumber',-2);\\nError: CHECK constraint failed: Products\\n\\nsqlite> SELECT * FROM Products;\\n1|radish|4\\n2|celery|7\\n\\nsqlite> UPDATE Products SET price=-2 WHERE id=2;\\nError: CHECK constraint failed: Products\\n\")), mdx(\"p\", null, \"Kun koetamme lis\\xE4t\\xE4 tauluun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Products\"), \" rivin, jossa hinta on negatiivinen, t\\xE4m\\xE4 rikkoo ehdon \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"price >= 0\"), \" ja SQLite ei salli rivin lis\\xE4\\xE4mist\\xE4 vaan antaa virheen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Error: CHECK constraint failed: Products\"), \". Samalla tavalla k\\xE4y, jos koetamme muuttaa olemassa olevan rivin sarakkeen hinnan negatiiviseksi j\\xE4lkeenp\\xE4in.\"), mdx(\"h2\", {\n    \"id\": \"viittausten-ehdot-reference-conditions\"\n  }, \"Viittausten ehdot (Reference conditions)\"), mdx(\"p\", null, \"Voimme liitt\\xE4\\xE4 my\\xF6s tauluihin ehtoja, jotka pit\\xE4v\\xE4t huolen siit\\xE4, ett\\xE4 tauluissa olevat viittaukset viittaavat todellisiin riveihin. T\\xE4m\\xE4 tapahtuu luomalla \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"viiteavain (foreign key)\"), \", joka ilmaisee, mihin taulussa oleva rivi viittaa.\"), mdx(\"p\", null, \"Tarkastellaan esimerkkin\\xE4 seuraavia tauluja:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Teachers (id INTEGER PRIMARY KEY, name TEXT);\\nCREATE TABLE Courses (id INTEGER PRIMARY KEY, name TEXT, teacher_id INTEGER);\\n\")), mdx(\"p\", null, \"T\\xE4ss\\xE4 tarkoituksena on, ett\\xE4 taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" sarake \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"teacher_id\"), \" viittaa taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" sarakkeeseen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \", mutta tietokannan k\\xE4ytt\\xE4j\\xE4 voi antaa sarakkeen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"teacher_id\"), \" arvoksi mit\\xE4 tahansa (esim. luvun 123), jolloin tietokannan sis\\xE4lt\\xF6 muuttuu ep\\xE4m\\xE4\\xE4r\\xE4iseksi.\"), mdx(\"p\", null, \"Voimme parantaa tilannetta kertomalla taulun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" luonnissa, ett\\xE4 sarake \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"teacher_id\"), \" on viiteavain tauluun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Courses (id INTEGER PRIMARY KEY, name TEXT, teacher_id INTEGER REFERENCES Teachers);\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4n j\\xE4lkeen voimme luottaa siihen, ett\\xE4 taulussa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" sarakkeen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"teacher_id\"), \" arvot viittaavat todellisiin riveihin taulussa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \".\"), mdx(\"h2\", {\n    \"id\": \"viiteavaimet-sqlitessä\"\n  }, \"Viiteavaimet SQLitess\\xE4\"), mdx(\"p\", null, \"Voimmeko oikeasti luottaa, ett\\xE4 viiteavaimet toimivat halutulla tavalla? Historiallisista syist\\xE4 SQLite ei oletuksena valvo viiteavainten ehtoja, vaan meid\\xE4n tulee ensin suorittaa seuraava komento:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> PRAGMA foreign_keys = ON;\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 on SQLiten erikoisuus, ja muissa tietokannoissa viiteavaimia \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pit\\xE4isi\"), \" aina valvoa.\"), mdx(\"p\", null, \"T\\xE4ss\\xE4 on esimerkki viiteavaimen k\\xE4ytt\\xE4misest\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> PRAGMA foreign_keys = ON;\\nsqlite> CREATE TABLE Teachers (id INTEGER PRIMARY KEY, name TEXT);\\nsqlite> CREATE TABLE Courses (id INTEGER PRIMARY KEY, name TEXT, teacher_id INTEGER\\n   ...>                       REFERENCES Teachers);\\nsqlite> INSERT INTO Teachers (name) VALUES ('Ahonen');\\nsqlite> INSERT INTO Teachers (name) VALUES ('Isohanni');\\nsqlite> SELECT * FROM Teachers;\\n1|Ahonen\\n2|Isohanni\\nsqlite> INSERT INTO Courses (name, teacher_id) VALUES ('Basic programming',2);\\nsqlite> INSERT INTO Courses (name, teacher_id) VALUES ('Algebra',123);\\nError: FOREIGN KEY constraint failed   \\n\")), mdx(\"p\", null, \"Taulussa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" on kaksi opettajaa, joiden \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \"-numerot ovat 1 ja 2. Niinp\\xE4 kun koetamme lis\\xE4t\\xE4 tauluun \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \" rivin, jossa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"teacher_id\"), \" on 123, SQLite ei salli t\\xE4t\\xE4 vaan saamme virheilmoituksen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Error: FOREIGN KEY constraint failed\"), \".\"), mdx(\"h2\", {\n    \"id\": \"viittaukset-ja-poistot\"\n  }, \"Viittaukset ja poistot\"), mdx(\"p\", null, \"Viittausten ehtoihin liittyy tavallisia sarakkeiden ehtoja mutkikkaampia tilanteita, koska viittaukset ovat kahden taulun v\\xE4lisi\\xE4. Erityisesti mit\\xE4 tapahtuu, jos taulusta yritet\\xE4\\xE4n poistaa rivi, johon viitataan toisen taulun rivill\\xE4?\"), mdx(\"p\", null, \"Yleens\\xE4 oletuksena tietokannoissa rivi\\xE4 ei voi poistaa, jos siihen on viittaus muualta. Esimerkiksi jos koetamme \\xE4skeisen esimerkin p\\xE4\\xE4tteeksi poistaa taulusta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Teachers\"), \" rivin 2, t\\xE4m\\xE4 ei onnistu, koska siihen viitataan taulussa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Courses\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"sqlite> DELETE FROM Teachers WHERE id=2;\\nError: FOREIGN KEY constraint failed\\n\")), mdx(\"p\", null, \"Halutessamme voimme kuitenkin m\\xE4\\xE4ritt\\xE4\\xE4 taulun luonnissa tarkemmin, mit\\xE4 tapahtuu t\\xE4ss\\xE4 tilanteessa. Esimerkiksi yksi vaihtoehto on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ON DELETE CASCADE\"), \", mik\\xE4 tarkoittaa, ett\\xE4 rivin poistuessa my\\xF6s siihen viittaavat rivit poistetaan. Saamme t\\xE4m\\xE4n aikaan n\\xE4in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"CREATE TABLE Courses (id INTEGER PRIMARY KEY, name TEXT,\\n      teacher_id INTEGER REFERENCES Teachers ON DELETE CASCADE);\\n\")), mdx(\"p\", null, \"Nyt jos tietokannasta poistetaan opettaja, niin samalla poistetaan automaattisesti kaikki kurssit, joita h\\xE4n opettaa. T\\xE4m\\xE4 voi kuitenkin olla kyseenalainen vaihtoehto, koska t\\xE4m\\xE4n seurauksena tietokannan tauluista voi kadota yll\\xE4tt\\xE4en tietoa.\"), mdx(\"h2\", {\n    \"id\": \"poiston-seuraukset\"\n  }, \"Poiston seuraukset\"), mdx(\"p\", null, \"Mahdollisia vaihtoehtoja \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ON DELETE\"), \" -osassa ovat:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NO ACTION\"), \": \\u201C\\xE4l\\xE4 tee mit\\xE4\\xE4n\\u201D (oletus)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RESTRICT\"), \": est\\xE4 poistaminen\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CASCADE\"), \": poista my\\xF6s viittaavat rivit\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SET NULL\"), \": muuta viittaukset arvoksi \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NULL\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SET DEFAULT\"), \": muuta viittaukset oletusarvoksi\")), mdx(\"p\", null, \"H\\xE4mment\\xE4v\\xE4 seikka on, ett\\xE4 my\\xF6s oletusvaihtoehto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NO ACTION\"), \" est\\xE4\\xE4 rivin poistamisen, vaikka nimest\\xE4 voisi p\\xE4\\xE4tell\\xE4 muuta. Vaihtoehdot \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NO ACTION\"), \" ja \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RESTRICT\"), \" toimivat k\\xE4yt\\xE4nn\\xF6ss\\xE4 l\\xE4hes samalla tavalla, mutta tietokannasta riippuen niiden toiminnassa voi olla eroja joissain erikoistilanteissa.\"), mdx(\"h1\", {\n    \"id\": \"johdatus-transaktioihin\"\n  }, \"Johdatus transaktioihin\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Transaktio (transaction)\"), \" on joukko per\\xE4kk\\xE4isi\\xE4 SQL-komentoja, jotka tietokantaj\\xE4rjestelm\\xE4 lupaa suorittaa yhten\\xE4 kokonaisuutena. Tietokannan k\\xE4ytt\\xE4j\\xE4 voi luottaa siihen, ett\\xE4 joko \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"kaikki komennot suoritetaan ja muutokset j\\xE4\\xE4v\\xE4t pysyv\\xE4sti tietokantaan tai\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"transaktio keskeytyy eiv\\xE4tk\\xE4 komennot aiheuta mit\\xE4\\xE4n muutoksia tietokantaan.\")), mdx(\"h2\", {\n    \"id\": \"acid\"\n  }, \"ACID\"), mdx(\"p\", null, \"Transaktioiden yhteydess\\xE4 esiintyy usein ihanteena kirjainyhdistelm\\xE4 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ACID\"), \", joka tulee seuraavista sanoista:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Atomicity: Transaktiossa olevat komennot suoritetaan yhten\\xE4 kokonaisuutena.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consistency: Transaktio s\\xE4ilytt\\xE4\\xE4 tietokannan sis\\xE4ll\\xF6n ehe\\xE4n\\xE4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Isolation: Transaktiot suoritetaan eristyksess\\xE4 toisistaan.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Durability: Loppuun viedyn transaktion tekem\\xE4t muutokset j\\xE4\\xE4v\\xE4t pysyviksi.\")), mdx(\"h2\", {\n    \"id\": \"transaktion-vaiheet\"\n  }, \"Transaktion vaiheet\"), mdx(\"p\", null, \"Itse asiassa transaktio on hyvin arkip\\xE4iv\\xE4inen asia tietokannan k\\xE4ytt\\xE4misess\\xE4, sill\\xE4 oletuksena jokainen suoritettava SQL-komento on oma transaktionsa. Tarkastellaan esimerkiksi seuraavaa komentoa, joka kasvattaa jokaisen tuotteen hintaa yhdell\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"UPDATE Products SET price=price+1;\\n\")), mdx(\"p\", null, \"Koska komento suoritetaan transaktiona, voimme luottaa siihen, ett\\xE4 joko jokaisen tuotteen hinta todella kasvaa yhdell\\xE4 tai sitten mink\\xE4\\xE4n tuotteen hinta ei muutu. J\\xE4lkimm\\xE4inen voi tapahtua esimerkiksi silloin, kun s\\xE4hk\\xF6t katkeavat kesken p\\xE4ivityksen. Siin\\xE4k\\xE4\\xE4n tapauksessa ei siis voi k\\xE4yd\\xE4 niin, ett\\xE4 vain osa hinnoista muuttuu.\"), mdx(\"p\", null, \"Usein kuitenkin sana transaktio viittaa erityisesti siihen, ett\\xE4 kokonaisuuteen kuuluu useampi SQL-komento. T\\xE4ll\\xF6in annamme ensin komennon \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BEGIN\"), \", joka aloittaa transaktion, sitten kaikki transaktioon kuuluvat komennot tavalliseen tapaan ja lopuksi komennon \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"COMMIT\"), \", joka p\\xE4\\xE4tt\\xE4\\xE4 transaktion.\"), mdx(\"p\", null, \"Klassinen esimerkki transaktiosta on tilanne, jossa pankissa siirret\\xE4\\xE4n rahaa tililt\\xE4 toiselle. Esimerkiksi seuraava transaktio siirt\\xE4\\xE4 100 euroa Maijan tililt\\xE4 Uolevin tilille:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"BEGIN TRANSACTION;\\nUPDATE Accounts SET balance=balance-100 WHERE owner='Maija';\\nUPDATE Accounts SET balance=balance+100 WHERE owner='Uolevi';\\nCOMMIT;\\n\")), mdx(\"p\", null, \"Transaktion ideana on, ett\\xE4 mit\\xE4\\xE4n pysyv\\xE4\\xE4 muutosta ei tapahdu ennen komentoa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"COMMIT\"), \". Niinp\\xE4 yll\\xE4 olevassa esimerkiss\\xE4 ei ole mahdollista, ett\\xE4 Maija menett\\xE4isi 100 euroa mutta Uolevi ei saisi mit\\xE4\\xE4n. Joko kummankin tilin saldo muuttuu ja rahat siirtyv\\xE4t onnistuneesti tai molemmat saldot s\\xE4ilyv\\xE4t entisell\\xE4\\xE4n.\"), mdx(\"p\", null, \"Jos transaktio keskeytyy jostain syyst\\xE4 ennen komentoa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"COMMIT\"), \", kaikki transaktiossa tehdyt muutokset peruuntuvat. Yksi syy transaktion keskeytymiseen on jokin h\\xE4iri\\xF6 tietokoneen toiminnassa (kuten s\\xE4hk\\xF6jen katkeaminen), mutta voimme my\\xF6s itse halutessamme keskeytt\\xE4\\xE4 transaktion antamalla komennon \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ROLLBACK\"), \".\"), mdx(\"h2\", {\n    \"id\": \"transaktioiden-kokeilu\"\n  }, \"Transaktioiden kokeilu\"), mdx(\"p\", null, \"Hyv\\xE4 tapa saada ymm\\xE4rryst\\xE4 transaktioista on kokeilla k\\xE4yt\\xE4nn\\xF6ss\\xE4, miten ne toimivat. T\\xE4ss\\xE4 on esimerkkin\\xE4 yksi keskustelu SQLiten kanssa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> CREATE TABLE Accounts (id INTEGER PRIMARY KEY, owner TEXT, balance INTEGER);\\nsqlite> INSERT INTO Accounts (owner,balance) VALUES ('Uolevi',350);\\nsqlite> INSERT INTO Accounts (owner,balance) VALUES ('Maija',600);\\n\\nsqlite> SELECT * FROM Accounts;\\n1|Uolevi|350\\n2|Maija|600\\n\\nsqlite> BEGIN TRANSACTION;\\nsqlite> UPDATE Accounts SET balance=balance-100 WHERE owner='Maija';\\nsqlite> SELECT * FROM Accounts;\\n1|Uolevi|350\\n2|Maija|500\\nsqlite> ROLLBACK;\\n\\nsqlite> SELECT * FROM Accounts;\\n1|Uolevi|350\\n2|Maija|600\\n\\nsqlite> BEGIN TRANSACTION;\\nsqlite> UPDATE Accounts SET balance=balance-100 WHERE owner='Maija';\\nsqlite> UPDATE Accounts SET balance=balance+100 WHERE owner='Uolevi';\\nsqlite> COMMIT;\\n\\nsqlite> SELECT * FROM Accounts;\\n1|Uolevi|450\\n2|Maija|500\\n\")), mdx(\"p\", null, \"Alkutilanteessa Uolevin tilill\\xE4 on 350 euroa ja Maijan tilill\\xE4 on 600 euroa. Ensimm\\xE4isess\\xE4 transaktiossa poistamme ensin Maijan tililt\\xE4 100 euroa, mutta sen j\\xE4lkeen tulemme toisiin ajatuksiin ja keskeyt\\xE4mme transaktion. Niinp\\xE4 transaktiossa tehty muutos peruuntuu ja tilien saldot ovat samat kuin alkutilanteessa. Toisessa transaktiossa viemme kuitenkin transaktion loppuun, mink\\xE4 seurauksena Uolevin tilill\\xE4 on 450 euroa ja Maijan tilill\\xE4 on 500 euroa.\"), mdx(\"p\", null, \"Huomaa, ett\\xE4 transaktion sis\\xE4ll\\xE4 muutokset kyll\\xE4 n\\xE4kyv\\xE4t, vaikka niit\\xE4 ei olisi tehty viel\\xE4 pysyv\\xE4sti tietokantaan. Esimerkiksi ensimm\\xE4isen transaktion \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT\"), \"-kysely antaa Maijan tilin saldoksi 500 euroa, koska edellinen \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE\"), \"-komento muutti saldoa.\"), mdx(\"h2\", {\n    \"id\": \"transaktioiden-sisäinen-toiminta\"\n  }, \"Transaktioiden sis\\xE4inen toiminta\"), mdx(\"p\", null, \"Transaktioiden toteuttaminen on kiehtova tekninen haaste tietokannoissa. Tavallaan transaktion tulee tehd\\xE4 muutoksia tietokantaan, koska komennot voivat riippua edellisist\\xE4 komennoista, mutta toisaalta mit\\xE4\\xE4n ei saa muuttaa pysyv\\xE4sti ennen transaktion viemist\\xE4 loppuun.\"), mdx(\"p\", null, \"Yksi keskeinen ajatus tietokantojen taustalla on tallentaa muutoksia kahdella tavalla. Ensin kuvaus muutoksesta kirjataan \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lokitiedostoon\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"write-ahead log\"), \"), jota voi ajatella luettelona suoritetuista komennoista. Vasta t\\xE4m\\xE4n j\\xE4lkeen muutokset tehd\\xE4\\xE4n tietokannan varsinaisiin tietorakenteisiin. Nyt jos j\\xE4lkimm\\xE4isess\\xE4 vaiheessa sattuu jotain yll\\xE4tt\\xE4v\\xE4\\xE4, muutokset ovat jo tallessa lokitiedostossa ja ne voidaan suorittaa my\\xF6hemmin uudestaan.\"), mdx(\"p\", null, \"Transaktioiden yhteydess\\xE4 tietokantaj\\xE4rjestelm\\xE4n t\\xE4ytyy my\\xF6s pit\\xE4\\xE4 kirjaa siit\\xE4, mitk\\xE4 muutokset ovat mink\\xE4kin meneill\\xE4\\xE4n olevan transaktion tekemi\\xE4. K\\xE4yt\\xE4nn\\xF6ss\\xE4 tauluihin voidaan tallentaa rivimuutoksia, jotka n\\xE4kyv\\xE4t vain tietyille transaktioille. Sitten jos transaktio p\\xE4\\xE4see loppuun asti, n\\xE4m\\xE4 muutokset liitet\\xE4\\xE4n taulun pysyv\\xE4ksi sis\\xE4ll\\xF6ksi.\"), mdx(\"h1\", {\n    \"id\": \"rinnakkaiset-transaktiot-parallel-transactions\"\n  }, \"Rinnakkaiset transaktiot (Parallel transactions)\"), mdx(\"p\", null, \"Lis\\xE4maustetta transaktioiden k\\xE4sittelyyn tuo se, ett\\xE4 tietokannalla voi olla useita k\\xE4ytt\\xE4ji\\xE4, joilla on meneill\\xE4\\xE4n samanaikaisia transaktioita. Miss\\xE4 m\\xE4\\xE4rin eri k\\xE4ytt\\xE4jien transaktiot tulisi erist\\xE4\\xE4 toisistaan?\"), mdx(\"p\", null, \"T\\xE4m\\xE4 on kysymys, johon ei ole yht\\xE4 oikeaa vastausta, vaan vastaus riippuu k\\xE4ytt\\xF6tilanteesta ja my\\xF6s tietokannan ominaisuuksista. Tavallaan paras ratkaisu olisi erist\\xE4\\xE4 transaktiot t\\xE4ydellisesti toisistaan, mutta toisaalta t\\xE4m\\xE4 voi haitata tietokannan k\\xE4ytt\\xE4mist\\xE4.\"), mdx(\"h2\", {\n    \"id\": \"transaktoiden-eristystasot-transaction-isolation-levels\"\n  }, \"Transaktoiden eristystasot (Transaction isolation levels)\"), mdx(\"p\", null, \"SQL-standardi m\\xE4\\xE4rittelee transaktioiden eristystasot seuraavasti:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Taso 1 (read uncommitted)\\nOn sallittua, ett\\xE4 transaktio pystyy n\\xE4kem\\xE4\\xE4n toisen transaktion tekem\\xE4n muutoksen, vaikka toista transaktiota ei ole viety loppuun (dirty read).\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Taso 2 (read committed)\\nToisin kuin tasolla 1, transaktio saa n\\xE4hd\\xE4 toisen transaktion tekem\\xE4n muutoksen vain, jos toinen transaktio on viety loppuun.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Taso 3 (repeatable read)\\nTason 2 vaatimus ja lis\\xE4ksi jos transaktion aikana luetaan saman rivin sis\\xE4lt\\xF6 useita kertoja, joka kerralla saadaan sama sis\\xE4lt\\xF6.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Taso 4 (serializable)\\nTransaktiot ovat t\\xE4ysin eristettyj\\xE4 ja komennot k\\xE4ytt\\xE4ytyv\\xE4t samoin kuin jos transaktiot olisi suoritettu per\\xE4kk\\xE4in yksi kerrallaan jossain j\\xE4rjestyksess\\xE4.\"))), mdx(\"h2\", {\n    \"id\": \"esimerkki\"\n  }, \"Esimerkki\"), mdx(\"p\", null, \"Tarkastellaan tilannetta, jossa tuotteen 1 hinta on aluksi 8 ja kaksi k\\xE4ytt\\xE4j\\xE4\\xE4 suorittaa samaan aikaan komentoja transaktioiden sis\\xE4ll\\xE4 (k\\xE4ytt\\xE4j\\xE4n 1 komennot ovat vasemmalla ja k\\xE4ytt\\xE4j\\xE4n 2 komennot ovat oikealla):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"BEGIN TRANSACTION;\\n                                       BEGIN TRANSACTION\\n                                       UPDATE Products SET price=5 WHERE id=1;\\nSELECT price FROM Products WHERE id=1;\\n                                       UPDATE Products SET price=7 WHERE id=1;\\n                                       COMMIT;\\nSELECT price FROM Products WHERE id=1;\\nCOMMIT;\\n\")), mdx(\"p\", null, \"Tasolla 1 k\\xE4ytt\\xE4j\\xE4 1 voi saada kyselyist\\xE4 tulokset 5 ja 7, koska k\\xE4ytt\\xE4j\\xE4n 2 tekem\\xE4t muutokset voivat tulla n\\xE4kyviin heti, vaikka k\\xE4ytt\\xE4j\\xE4n 2 transaktioita ei ole viety loppuun.\"), mdx(\"p\", null, \"Tasolla 2 k\\xE4ytt\\xE4j\\xE4 1 voi saada kyselyist\\xE4 tulokset 8 ja 7, koska ensimm\\xE4isen kyselyn kohdalla toista transaktiota ei ole viety loppuun, kun taas toisen kyselyn kohdalla se on viety loppuun.\"), mdx(\"p\", null, \"Tasoilla 3 ja 4 k\\xE4ytt\\xE4j\\xE4 1 saa kyselyist\\xE4 tulokset 8 ja 8, koska t\\xE4m\\xE4 on tilanne ennen transaktion alkua eik\\xE4 v\\xE4liss\\xE4 loppuun viety transaktio saa muuttaa luettua rivin sis\\xE4lt\\xF6\\xE4.\"), mdx(\"h2\", {\n    \"id\": \"transaktiot-käytännössä\"\n  }, \"Transaktiot k\\xE4yt\\xE4nn\\xF6ss\\xE4\"), mdx(\"p\", null, \"Transaktioiden toteutustavat ja saatavilla olevat eristystasot riippuvat k\\xE4ytetyst\\xE4 tietokantaj\\xE4rjestelm\\xE4st\\xE4. Esimerkiksi SQLitess\\xE4 ainoa mahdollinen taso on 4, kun taas PostgreSQL toteuttaa tasot 2\\u20134 ja oletuksena k\\xE4yt\\xF6ss\\xE4 on taso 2.\"), mdx(\"h2\", {\n    \"id\": \"miksi-käyttää-eri-tasoja\"\n  }, \"Miksi k\\xE4ytt\\xE4\\xE4 eri tasoja?\"), mdx(\"p\", null, \"Eristystaso 4 on tavallaan selke\\xE4sti paras, koska silloin transaktioiden muutokset eiv\\xE4t voi n\\xE4ky\\xE4 mitenk\\xE4\\xE4n toisilleen. Miksi edes muut tasot ovat olemassa ja miksi esimerkiksi PostgreSQL:n oletustaso on 2?\"), mdx(\"p\", null, \"Hyv\\xE4n erist\\xE4misen hintana on, ett\\xE4 se voi hidastaa tai est\\xE4\\xE4 transaktioiden suorittamista, koska transaktion vieminen loppuun voisi aiheuttaa ristiriitaisen tilanteen. Toisaalta monissa k\\xE4yt\\xE4nn\\xF6n tilanteissa riitt\\xE4\\xE4 mainiosti heikompikin eristys, kunhan tietokannan k\\xE4ytt\\xE4j\\xE4 on siit\\xE4 tietoinen.\"), mdx(\"p\", null, \"Hyv\\xE4\\xE4 tietoa rinnakkaisten transaktioiden toiminnasta saa perehtym\\xE4ll\\xE4 k\\xE4ytetyn tietokannan dokumentaatioon sek\\xE4 testailemalla asioita itse k\\xE4yt\\xE4nn\\xF6ss\\xE4. Esimerkiksi voimme k\\xE4ynnist\\xE4\\xE4 itse \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"kaksi\"), \" SQLite-tulkkia, avata niill\\xE4 saman tietokannan ja sen j\\xE4lkeen kirjoittaa transaktioita sis\\xE4lt\\xE4vi\\xE4 komentoja ja tehd\\xE4 havaintoja.\"), mdx(\"p\", null, \"Seuraava keskustelu n\\xE4ytt\\xE4\\xE4 edellisen esimerkin tuloksen kahdessa rinnakkain k\\xE4ynniss\\xE4 olevassa SQLite-tulkissa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"sqlite> BEGIN TRANSACTION;\\n                                 sqlite> BEGIN TRANSACTION;\\n                                 sqlite> UPDATE Products SET price=5 WHERE id=1;\\nsqlite> SELECT price FROM Products WHERE id=1;\\n8\\n                                 sqlite> UPDATE Products SET price=7 WHERE id=1;\\n                                 sqlite> COMMIT;\\n                                 Error: database is locked\\nsqlite> SELECT price FROM Products WHERE id=1;\\n8\\nsqlite> COMMIT;\\n\")), mdx(\"p\", null, \"T\\xE4st\\xE4 n\\xE4kee, ett\\xE4 ensimm\\xE4inen transaktio tosiaan saa kummastakin kyselyst\\xE4 tuloksen 8. Toista transaktiota ei sen sijaan saada viety\\xE4 loppuun, vaan tulee virheviesti \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Error: database is locked\"), \", koska tietokanta on lukittuna samanaikaisen transaktion takia. Eristys toimii siis hyvin, mutta toista transaktiota pit\\xE4isi yritt\\xE4\\xE4 vied\\xE4 loppuun uudestaan.\"), mdx(\"p\", null, \"Vertailun vuoksi t\\xE4ss\\xE4 on vastaava keskustelu PostgreSQL-tulkeissa (tasolla 2):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"user=> BEGIN TRANSACTION;\\n                                 user=> BEGIN TRANSACTION;\\n                                 user=> UPDATE Products SET price=5 WHERE id=1;\\nuser=> SELECT price FROM Products WHERE id=1;\\n8\\n                                 user=> UPDATE Products SET price=7 WHERE id=1;\\n                                 user=> COMMIT;\\nuser=> SELECT price FROM Products WHERE id=1;\\n7\\nuser=> COMMIT;\\n\")), mdx(\"p\", null, \"Nyt toisen transaktion muuttama arvo 7 ilmestyy ensimm\\xE4iseen transaktioon, mutta toisaalta molemmat transaktiot saadaan viety\\xE4 loppuun ongelmitta.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#tiedon-eheys-data-integrity","title":"Tiedon eheys (data integrity)","items":[{"url":"#sarakkeiden-ehdot-column-conditions","title":"Sarakkeiden ehdot (Column conditions)"},{"url":"#unique","title":"UNIQUE"},{"url":"#not-null-ja-default","title":"NOT NULL ja DEFAULT"},{"url":"#check","title":"CHECK"},{"url":"#ehtojen-valvonta-condition-monitoring","title":"Ehtojen valvonta (Condition monitoring)"},{"url":"#viittausten-ehdot-reference-conditions","title":"Viittausten ehdot (Reference conditions)"},{"url":"#viiteavaimet-sqlitessä","title":"Viiteavaimet SQLitessä"},{"url":"#viittaukset-ja-poistot","title":"Viittaukset ja poistot"},{"url":"#poiston-seuraukset","title":"Poiston seuraukset"}]},{"url":"#johdatus-transaktioihin","title":"Johdatus transaktioihin","items":[{"url":"#acid","title":"ACID"},{"url":"#transaktion-vaiheet","title":"Transaktion vaiheet"},{"url":"#transaktioiden-kokeilu","title":"Transaktioiden kokeilu"},{"url":"#transaktioiden-sisäinen-toiminta","title":"Transaktioiden sisäinen toiminta"}]},{"url":"#rinnakkaiset-transaktiot-parallel-transactions","title":"Rinnakkaiset transaktiot (Parallel transactions)","items":[{"url":"#transaktoiden-eristystasot-transaction-isolation-levels","title":"Transaktoiden eristystasot (Transaction isolation levels)"},{"url":"#esimerkki","title":"Esimerkki"},{"url":"#transaktiot-käytännössä","title":"Transaktiot käytännössä"},{"url":"#miksi-käyttää-eri-tasoja","title":"Miksi käyttää eri tasoja?"}]}]},"frontmatter":{"title":"Tiedon eheys"}}},"pageContext":{"id":"de9644f4-f649-53db-8e81-a341ec04dab1"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}